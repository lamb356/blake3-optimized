/**
 * Tests against official Bao test vectors
 * https://github.com/oconnor663/bao/blob/master/tests/test_vectors.json
 */

const fs = require('fs');
const path = require('path');
const blake3 = require('./blake3.js');
const bao = require('./bao.js');

// Load official test vectors
const vectors = JSON.parse(fs.readFileSync(path.join(__dirname, 'test-vectors.json'), 'utf8'));

function toHex(bytes) {
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

function fromHex(hex) {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return bytes;
}

/**
 * Generate test input as specified in test vectors:
 * "Input bytes are generated by incrementing a 4-byte little-endian integer, starting with 1"
 */
function generateInput(length) {
  const input = new Uint8Array(length);
  let counter = 1;
  for (let i = 0; i < length; i += 4) {
    // Write counter as 4-byte little-endian
    const remaining = Math.min(4, length - i);
    for (let j = 0; j < remaining; j++) {
      input[i + j] = (counter >> (j * 8)) & 0xff;
    }
    counter++;
  }
  return input;
}

let passed = 0;
let failed = 0;

function test(name, fn) {
  try {
    fn();
    console.log(`PASS: ${name}`);
    passed++;
  } catch (e) {
    console.log(`FAIL: ${name}`);
    console.log(`  Error: ${e.message}`);
    failed++;
  }
}

function assertEqual(actual, expected, msg) {
  if (actual !== expected) {
    throw new Error(`${msg}\n  Expected: ${expected}\n  Got: ${actual}`);
  }
}

function assertArrayEqual(actual, expected, msg) {
  if (actual.length !== expected.length) {
    throw new Error(`${msg}\n  Length mismatch: ${actual.length} vs ${expected.length}`);
  }
  for (let i = 0; i < actual.length; i++) {
    if (actual[i] !== expected[i]) {
      throw new Error(`${msg}\n  Mismatch at index ${i}: ${actual[i]} vs ${expected[i]}`);
    }
  }
}

console.log('Bao Official Test Vectors');
console.log('=========================\n');

// ============================
// Input Generation Verification
// ============================
console.log('--- Input Generation ---\n');

test('Input generation matches spec example', () => {
  // "For example, an input of length 10 would be the bytes [1, 0, 0, 0, 2, 0, 0, 0, 3, 0]"
  const input = generateInput(10);
  const expected = new Uint8Array([1, 0, 0, 0, 2, 0, 0, 0, 3, 0]);
  assertArrayEqual(input, expected, 'Input generation');
});

// ============================
// Hash Tests
// ============================
console.log('\n--- Hash Tests (Official Vectors) ---\n');

for (const vec of vectors.hash) {
  test(`Hash: ${vec.input_len} bytes`, () => {
    const input = generateInput(vec.input_len);
    const result = bao.baoEncode(input);
    const actualHash = toHex(result.hash);
    assertEqual(actualHash, vec.bao_hash, `Hash for ${vec.input_len} bytes`);
  });
}

// ============================
// Encode Tests
// ============================
console.log('\n--- Encode Tests (Official Vectors) ---\n');

for (const vec of vectors.encode) {
  test(`Encode size: ${vec.input_len} bytes -> ${vec.output_len} bytes`, () => {
    const input = generateInput(vec.input_len);
    const result = bao.baoEncode(input);
    assertEqual(result.encoded.length, vec.output_len, `Encoded size for ${vec.input_len} bytes`);
  });

  test(`Encode hash: ${vec.input_len} bytes`, () => {
    const input = generateInput(vec.input_len);
    const result = bao.baoEncode(input);
    const actualHash = toHex(result.hash);
    assertEqual(actualHash, vec.bao_hash, `Bao hash for ${vec.input_len} bytes`);
  });

  test(`Encode content hash: ${vec.input_len} bytes`, () => {
    const input = generateInput(vec.input_len);
    const result = bao.baoEncode(input);
    // The encoded_blake3 is the BLAKE3 hash of the entire encoding
    const encodedHash = toHex(blake3.hash(result.encoded));
    assertEqual(encodedHash, vec.encoded_blake3, `Encoded BLAKE3 hash for ${vec.input_len} bytes`);
  });
}

// ============================
// Corruption Detection Tests
// ============================
console.log('\n--- Corruption Detection (Official Vectors) ---\n');

for (const vec of vectors.encode) {
  if (vec.corruptions && vec.corruptions.length > 0) {
    test(`Corruption detection: ${vec.input_len} bytes (${vec.corruptions.length} positions)`, () => {
      const input = generateInput(vec.input_len);
      const result = bao.baoEncode(input);

      for (const pos of vec.corruptions) {
        const corrupted = new Uint8Array(result.encoded);
        corrupted[pos] ^= 1; // Flip one bit

        let detected = false;
        try {
          bao.baoDecode(corrupted, result.hash);
        } catch (e) {
          detected = true;
        }

        if (!detected) {
          throw new Error(`Corruption at position ${pos} not detected`);
        }
      }
    });
  }
}

// ============================
// Outboard Tests
// ============================
console.log('\n--- Outboard Tests (Official Vectors) ---\n');

for (const vec of vectors.outboard) {
  test(`Outboard size: ${vec.input_len} bytes -> ${vec.output_len} bytes`, () => {
    const input = generateInput(vec.input_len);
    const result = bao.baoEncode(input, true);
    assertEqual(result.encoded.length, vec.output_len, `Outboard size for ${vec.input_len} bytes`);
  });

  test(`Outboard hash: ${vec.input_len} bytes`, () => {
    const input = generateInput(vec.input_len);
    const result = bao.baoEncode(input, true);
    const actualHash = toHex(result.hash);
    assertEqual(actualHash, vec.bao_hash, `Outboard hash for ${vec.input_len} bytes`);
  });

  test(`Outboard content hash: ${vec.input_len} bytes`, () => {
    const input = generateInput(vec.input_len);
    const result = bao.baoEncode(input, true);
    const encodedHash = toHex(blake3.hash(result.encoded));
    assertEqual(encodedHash, vec.encoded_blake3, `Outboard BLAKE3 hash for ${vec.input_len} bytes`);
  });
}

// ============================
// Outboard Corruption Detection
// ============================
console.log('\n--- Outboard Corruption Detection ---\n');

for (const vec of vectors.outboard) {
  // Test encoded_corruptions (corruption in the outboard tree)
  if (vec.encoded_corruptions && vec.encoded_corruptions.length > 0) {
    test(`Outboard tree corruption: ${vec.input_len} bytes`, () => {
      const input = generateInput(vec.input_len);
      const result = bao.baoEncode(input, true);

      for (const pos of vec.encoded_corruptions) {
        const corrupted = new Uint8Array(result.encoded);
        corrupted[pos] ^= 1;

        let detected = false;
        try {
          bao.baoDecode(corrupted, result.hash, input);
        } catch (e) {
          detected = true;
        }

        if (!detected) {
          throw new Error(`Outboard tree corruption at position ${pos} not detected`);
        }
      }
    });
  }

  // Test input_corruptions (corruption in the original data)
  if (vec.input_corruptions && vec.input_corruptions.length > 0) {
    test(`Outboard data corruption: ${vec.input_len} bytes`, () => {
      const input = generateInput(vec.input_len);
      const result = bao.baoEncode(input, true);

      for (const pos of vec.input_corruptions) {
        const corruptedInput = new Uint8Array(input);
        corruptedInput[pos] ^= 1;

        let detected = false;
        try {
          bao.baoDecode(result.encoded, result.hash, corruptedInput);
        } catch (e) {
          detected = true;
        }

        if (!detected) {
          throw new Error(`Outboard input corruption at position ${pos} not detected`);
        }
      }
    });
  }
}

// ============================
// Slice Tests
// ============================
console.log('\n--- Slice Tests (Official Vectors) ---\n');

for (const vec of vectors.slice) {
  for (const slice of vec.slices) {
    test(`Slice: ${vec.input_len} bytes, range [${slice.start}, ${slice.start + slice.len})`, () => {
      const input = generateInput(vec.input_len);
      const { encoded, hash } = bao.baoEncode(input);

      // Extract slice
      const sliceData = bao.baoSlice(encoded, slice.start, slice.len);

      // Verify slice size matches expected
      assertEqual(sliceData.length, slice.output_len, `Slice size for [${slice.start}, ${slice.len})`);

      // Verify BLAKE3 hash of slice matches expected
      const sliceHash = toHex(blake3.hash(sliceData));
      assertEqual(sliceHash, slice.output_blake3, `Slice BLAKE3 hash`);

      // Verify slice decodes correctly
      const decoded = bao.baoDecodeSlice(sliceData, hash, slice.start, slice.len);

      // Calculate expected decoded content
      const expectedStart = Math.min(slice.start, vec.input_len);
      const expectedEnd = Math.min(slice.start + slice.len, vec.input_len);
      const expectedLen = Math.max(0, expectedEnd - expectedStart);

      assertEqual(decoded.length, expectedLen, `Decoded slice length`);

      if (expectedLen > 0) {
        assertArrayEqual(decoded, input.subarray(expectedStart, expectedEnd), `Decoded slice content`);
      }
    });
  }
}

// ============================
// Slice Corruption Detection
// ============================
console.log('\n--- Slice Corruption Detection ---\n');

for (const vec of vectors.slice) {
  for (const slice of vec.slices) {
    if (slice.corruptions && slice.corruptions.length > 0) {
      test(`Slice corruption: ${vec.input_len} bytes, [${slice.start}, ${slice.start + slice.len})`, () => {
        const input = generateInput(vec.input_len);
        const { encoded, hash } = bao.baoEncode(input);
        const sliceData = bao.baoSlice(encoded, slice.start, slice.len);

        for (const pos of slice.corruptions) {
          const corrupted = new Uint8Array(sliceData);
          corrupted[pos] ^= 1;

          let detected = false;
          try {
            bao.baoDecodeSlice(corrupted, hash, slice.start, slice.len);
          } catch (e) {
            detected = true;
          }

          if (!detected) {
            throw new Error(`Slice corruption at position ${pos} not detected`);
          }
        }
      });
    }
  }
}

// ============================
// Round-trip Verification
// ============================
console.log('\n--- Round-trip Verification ---\n');

for (const vec of vectors.hash) {
  test(`Round-trip: ${vec.input_len} bytes`, () => {
    const input = generateInput(vec.input_len);
    const { encoded, hash } = bao.baoEncode(input);
    const decoded = bao.baoDecode(encoded, hash);
    assertArrayEqual(decoded, input, `Round-trip for ${vec.input_len} bytes`);
  });
}

// ============================
// Summary
// ============================
console.log('\n=========================');
console.log(`Results: ${passed} passed, ${failed} failed`);

if (failed === 0) {
  console.log('\nAll official Bao test vectors passed!');
} else {
  console.log('\nSome tests failed.');
  process.exit(1);
}
